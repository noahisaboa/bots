#pragma config(Sensor, in1,    PRT_clawWristPot,   sensorPotentiometer)
#pragma config(Sensor, dgtl1,  PRT_liftTouch,      sensorTouch)
#pragma config(Sensor, dgtl2,  PRT_liftEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl4,  PRT_clawLiftEncoder, sensorQuadEncoder)
#pragma config(Sensor, dgtl6,  PRT_sonar,          sensorSONAR_inch)
#pragma config(Sensor, dgtl10, PRT_ledR,           sensorLEDtoVCC)
#pragma config(Sensor, dgtl11, PRT_ledY,           sensorLEDtoVCC)
#pragma config(Sensor, dgtl12, PRT_ledG,           sensorLEDtoVCC)
#pragma config(Motor,  port1,  PRT_clawWristMotor, tmotorVexFlashlight, openLoop, reversed)
#pragma config(Motor,  port2,  PRT_clawMotor,     tmotorVexFlashlight, openLoop, reversed)
#pragma config(Motor,  port3,  PRT_liftMotor1,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,  PRT_wheelFrontRight, tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port5,  PRT_wheelBackRight, tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port6,  PRT_wheelFrontLeft, tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port7,  PRT_wheelBackLeft, tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port8,  PRT_clawLiftMotor, tmotorVexFlashlight, openLoop, reversed)
#pragma config(Motor,  port9,  PRT_liftMotor2,    tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//////////////////////////////////////////////////////////////////////////////////////
//								--= TRIPLE LIFT BOT =--								//
//////////////////////////////////////////////////////////////////////////////////////
// The purpose of this file is to link all of the modules together into a working,  //
// intelligent robot. The robot starts by calibrating its systems, then enables its //
// autonomous mode. After this, user input is converted to instructions during the  //
// user control period.                                                             //
//////////////////////////////////////////////////////////////////////////////////////

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

//////////////////
// DEPENDENCIES //
//////////////////

#include "BlinkModule.c"
#include "BatteryModule.c"
#include "DriverControlModule.c"
#include "PIDLoopModule.c"
#include "AutonomousModule.c"

//////////////////////////
// PRE-AUTONOMOUS SETUP //
//////////////////////////

void pre_auton()
{
	writeDebugStreamLine("[Mode]: Setting up the robot...");
	// Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
	// Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
	bStopTasksBetweenModes = false; // This must be disabled to allow the PID Loop.

	// Initialize the blink debug handler.
	// Each blink task has an ID that must be held in order to stop the task later.
	startTask(LED_blink);
	short id = LED_startBlinkTask(Info, Medium);

	// Initialize the driver configuration and button "event" handler.
	startTask(DRV_buttonHandler);

	// Initialize the battery monitor.
	startTask(BAT_monitor);

	// Calibrate the PID's individual systems.
	PID_calibrate();

	wait1Msec(500);
	LED_stopBlinkTask(id);
	writeDebugStreamLine("[Mode]: Setup complete!");
}

/////////////////////
// AUTONOMOUS MODE //
/////////////////////

task autonomous()
{
	// Autonomous mode is not currently in a stage to be operated...
	/*short id = LED_startBlinkTask(Info, Slow);
	writeDebugStreamLine("[Mode]: Autonomous mode enabled!");
	float PRT_sonarAverage = 0;
	repeat (10) {
		PRT_sonarAverage += SensorValue[PRT_sonar];
		wait1Msec(10);
	}
	PRT_sonarAverage = PRT_sonarAverage / 10;

	if (PRT_sonarAverage <= 25) {
		// Placed further from autoloader.
		strafe(-127); // Move up to the corner.
		while (SensorValue[PRT_sonar] > 2) {
			wait1Msec(10);
		}
		halt();
		rotate(-127, 1); // Face the wall.
		strafe(-127, 1); // Meet the autoloader.
		wait1Msec(3000); // Grab the tower segment.
		rotate(-127, 2); // Face the tower base.
		wait1Msec(3000); // Place the tower base.
		rotate(127, 2);  // Face the wall.
		strafe(-127);	 // Meet the corner.
		while (SensorValue[PRT_sonar] > 2) {
			wait1Msec(10);
		}
		halt();
		rotate(-127, 3); // Face opposite the wall.
		strafe(127); // Return to base.
		while (SensorValue[PRT_sonar] < 25) {
			wait1Msec(10);
		}
		halt();
	} else {
		// Placed close to the autoloader. Life is easy!
		rotate(127, 2); // Turn all the way around.
		strafe(-64, 1);
		wait1Msec(3000); // Grab the tower segment.
		rotate(127, 2);
		wait1Msec(3000); // Place the tower segment.
		strafe(-64, 1);
	}
	writeDebugStreamLine("[Mode]: Autonomous mode disabled!");
	LED_stopBlinkTask(id);*/
}

///////////////////////////
//// USER CONTROL MODE ////
///////////////////////////

task usercontrol()
{
	writeDebugStreamLine("[Mode]: User Control mode enabled!");
	// Continually check for user input.
	while (true) {
		// Claw Control
		// Lookup the keybinding and check to see if the button is down (event type).
		if (DRV_controllerButtonsDown[ClawClamp] == true) {
			// Ensure that the claw has maximal power, then toggle it.
			if (abs(motor[PRT_clawMotor]) != 127) {
				motor[PRT_clawMotor] = 127;
			}
			motor[PRT_clawMotor] = -1 * motor[PRT_clawMotor];
			// Cancel the event since we are done with it until it is pressed again.
			DRV_controllerButtonsDown[ClawClamp] = false;
		}
		// Claw Wrist
		// If the up button is assigned, and is pressed (not event type).
		if (DRV_config[ClawWristUp] != UNASSIGNED && vexRT[DRV_config[ClawWristUp]] == true) {
			if (PID_enabled[ClawWrist] == true) {
				// Increment if PID is enable for this system.
				PID_target[ClawWrist] += PID_CONTROL_INCREMENTER_UP[ClawWrist];
			} else {
				// Otherwise, set a raw value.
				motor[PRT_clawWristMotor] = 127;
			}
		} else if (DRV_config[ClawWristDown] != UNASSIGNED && vexRT[DRV_config[ClawWristDown]] == true) {
			if (PID_enabled[ClawWrist] == true) {
				PID_target[ClawWrist] -= PID_CONTROL_INCREMENTER_DOWN[ClawWrist];
			} else {
				motor[PRT_clawWristMotor] = -127;
			}
		} else if (DRV_config[ClawWristJoy] != UNASSIGNED) {
			if (PID_enabled[ClawWrist] == true) {
				// Trim the claw wrist's joystick's value.
				float power = (int) DRV_trimChannel(ClawWristJoy, 5);
				if (power >= 0) {
					// Scale the incremented target value.
					PID_target[ClawWrist] += (power / 127) * PID_CONTROL_INCREMENTER_UP[ClawWrist];
				} else {
					PID_target[ClawWrist] += (power / 127) * PID_CONTROL_INCREMENTER_DOWN[ClawWrist];
				}
			} else {
				motor[PRT_clawWristMotor] = DRV_trimChannel(ClawWristJoy, 5);
			}
		}
		// Claw Lift
		if (DRV_config[ClawLiftUp] != UNASSIGNED && vexRT[DRV_config[ClawLiftUp]] == true) {
			if (PID_enabled[ClawLift] == true) {
				PID_target[ClawLift] += PID_CONTROL_INCREMENTER_UP[ClawLift];
			} else {
				motor[PRT_clawLiftMotor] = 127;
			}
		} else if (DRV_config[ClawLiftDown] != UNASSIGNED && vexRT[DRV_config[ClawLiftDown]] == true) {
			if (PID_enabled[ClawLift] == true) {
				PID_target[ClawLift] -= PID_CONTROL_INCREMENTER_DOWN[ClawLift];
			} else {
				motor[PRT_clawLiftMotor] = -64;
			}
		} else if (DRV_config[ClawLiftJoy] != UNASSIGNED) {
			if (PID_enabled[ClawLift] == true) {
				float power = (int) DRV_trimChannel(ClawLiftJoy, 5);
				if (power >= 0) {
					PID_target[ClawLift] += (power / 127) * PID_CONTROL_INCREMENTER_UP[ClawLift];
				} else {
					PID_target[ClawLift] += (power / 127) * PID_CONTROL_INCREMENTER_DOWN[ClawLift];
				}
			} else {
				motor[PRT_clawLiftMotor] = DRV_trimChannel(ClawLiftJoy, 5);
			}
		}
		// Claw Lift Macros
		// If the button is pressed down (event type), set the system's PID target to the max, or bring it to the top.
		if (DRV_controllerButtonsDown[ClawLiftTopMacro] == true) {
			PID_target[ClawLift] = PID_targetMax[ClawLift];
			DRV_controllerButtonsDown[ClawLiftTopMacro] = false;
		} else if (DRV_controllerButtonsDown[ClawLiftBottomMacro] == true) {
			PID_target[ClawLift] = 0;
			DRV_controllerButtonsDown[ClawLiftBottomMacro] = false;
		}

		// Lift Control
		if (DRV_config[LiftUp] != UNASSIGNED && vexRT[DRV_config[LiftUp]] == true) {
			if (PID_enabled[MainLift] == true)
				PID_target[MainLift] += PID_CONTROL_INCREMENTER_UP[MainLift];
			else {
				motor[PRT_liftMotor1] = 127;
				motor[PRT_liftMotor2] = 127;
			}
		} else if (DRV_config[LiftDown] != UNASSIGNED && vexRT[DRV_config[LiftDown]] == true) {
			if (PID_enabled[MainLift])
				PID_target[MainLift] -= PID_CONTROL_INCREMENTER_DOWN[MainLift];
			else {
				motor[PRT_liftMotor1] = -64;
				motor[PRT_liftMotor2] = -64;
			}
		} else if (vexRT[DRV_config[LiftJoy]] != UNASSIGNED) {
			// Get the power value view the joystick, then apply the proportional power to the lift. (Scaled to incrementer)
			float power = (int) DRV_trimChannel(LiftJoy);
			if (PID_enabled[MainLift]) {
				if (power >= 0) {
					PID_target[MainLift] += (power / 127) * PID_CONTROL_INCREMENTER_UP[MainLift];
				} else {
					PID_target[MainLift] += (power / 127) * PID_CONTROL_INCREMENTER_DOWN[MainLift];
				}
			}
			else {
				motor[PRT_liftMotor1] = power;
				motor[PRT_liftMotor2] = power;
			}
		} else if (!PID_enabled[MainLift]) {
			motor[PRT_liftMotor1] = 0;
			motor[PRT_liftMotor2] = 0;
		}
		// Lift Macros
		if (DRV_controllerButtonsDown[LiftTopMacro] == true) {
			PID_target[MainLift] = PID_targetMax[MainLift];
			DRV_controllerButtonsDown[LiftTopMacro] = false;
		} else if (DRV_controllerButtonsDown[LiftBottomMacro] == true) {
			PID_target[MainLift] = 0;
			DRV_controllerButtonsDown[LiftBottomMacro] = false;
		}

		// Wheel Control
		if (DRV_config[MecanumRotate] == UNASSIGNED) {
			// 4 channel (tank) drive  enabled.
			int threshold = 20;
			int RX = DRV_trimChannel(MecanumRightStrafe);
			int RY = DRV_trimChannel(MecanumRightNormal);
			int LX = DRV_trimChannel(MecanumLeftStrafe);
			int LY = DRV_trimChannel(MecanumLeftNormal);

			if (abs(RX) < threshold) {
				// Straight
				motor[PRT_wheelFrontRight] = RY;
				motor[PRT_wheelBackRight] = RY;
			} else if (RX > threshold) {
				// Right
				motor[PRT_wheelFrontRight] = RX;
				motor[PRT_wheelBackRight] = -RX;
			} else if (RX < -threshold) {
				// Left
				motor[PRT_wheelFrontRight] = RX;
				motor[PRT_wheelBackRight] = -RX;
			} else {
				// Stop
				motor[PRT_wheelFrontRight] = 0;
				motor[PRT_wheelBackRight] = 0;
			}

			if (abs(LX) < threshold) {
				// Straight
				motor[PRT_wheelFrontLeft] = LY;
				motor[PRT_wheelBackLeft] = LY;
			} else if (LX > threshold) {
				// Right
				motor[PRT_wheelFrontLeft] = -LX;
				motor[PRT_wheelBackLeft] = LX;
			} else if (LX < -threshold) {
				// Left
				motor[PRT_wheelFrontLeft] = -LX;
				motor[PRT_wheelBackLeft] = LX;
			} else {
				// Stop
				motor[PRT_wheelFrontLeft] = 0;
				motor[PRT_wheelBackLeft] = 0;
			}
		} else {
			// 3 channel (smart) drive enabled.
			motor[PRT_wheelFrontRight] 	= DRV_trimChannel(MecanumRightNormal)
				- DRV_trimChannel(MecanumRotate)
				+ DRV_trimChannel(MecanumRightStrafe);
   			motor[PRT_wheelBackRight] 	= DRV_trimChannel(MecanumRightNormal)
   				+ abs(DRV_trimChannel(MecanumRotate))
   				- DRV_trimChannel(MecanumRightStrafe);
    		motor[PRT_wheelFrontLeft] 	= DRV_trimChannel(MecanumLeftNormal)
    			+ DRV_trimChannel(MecanumRotate)
    			- DRV_trimChannel(MecanumLeftStrafe);
    		motor[PRT_wheelBackLeft] 	= DRV_trimChannel(MecanumLeftNormal)
    			+ abs(DRV_trimChannel(MecanumRotate))
    			+ DRV_trimChannel(MecanumLeftStrafe);
		}

		// Override controls
		if (DRV_controllerButtonsDown[PidOverride] == true) {
			// If a combination of the override button and a system button are pressed, toggle that particular system's PID.
			if (vexRT[DRV_config[LiftUp]] == true || vexRT[DRV_config[LiftDown]] == true
					|| DRV_trimChannel(LiftJoy) != 0) {
				// Toggle the main lift system then reset motors.
				PID_enabled[MainLift] = !PID_enabled[MainLift];
				motor[PRT_liftMotor1] = 0;
				motor[PRT_liftMotor2] = 0;
				// Indicate to the DriverControlModule that we have recieved the button press.
				DRV_controllerButtonsDown[PidOverride] = false;
			} else if (vexRT[DRV_config[ClawLiftUp]] == true || vexRT[DRV_config[ClawLiftDown]] == true
					|| DRV_trimChannel(ClawLiftJoy) != 0) {
				// Toggle the claw lift system then reset motors.
				PID_enabled[ClawLift] = !PID_enabled[ClawLift];
				motor[PRT_clawLiftMotor] = 0;
				DRV_controllerButtonsDown[PidOverride] = false;
			} else if (vexRT[DRV_config[ClawWristUp]] == true || vexRT[DRV_config[ClawWristDown]] == true
					|| DRV_trimChannel(ClawWristJoy) != 0) {
				// Toggle the claw wrist system then reset motors.
				PID_enabled[ClawWrist] = !PID_enabled[ClawWrist];
				motor[PRT_clawWristMotor] = 0;
				DRV_controllerButtonsDown[PidOverride] = false;
			}
			// No systems were designated. Exit WITHOUT accepting button down event.
		}
	}
	writeDebugStreamLine("[Mode]: User Control mode disabled!");
}
