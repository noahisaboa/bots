#pragma config(Sensor, in1,    clawWristPot,   sensorPotentiometer)
#pragma config(Sensor, dgtl1,  liftTouch,      sensorTouch)
#pragma config(Sensor, dgtl2,  liftEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl4,  clawLiftEncoder, sensorQuadEncoder)
#pragma config(Sensor, dgtl6,  sonar,          sensorSONAR_inch)
#pragma config(Sensor, dgtl10, LEDR,           sensorLEDtoVCC)
#pragma config(Sensor, dgtl11, LEDY,           sensorLEDtoVCC)
#pragma config(Sensor, dgtl12, LEDG,           sensorLEDtoVCC)
#pragma config(Motor,  port1,           clawWristMotor, tmotorVexFlashlight, openLoop, reversed)
#pragma config(Motor,  port2,           clawMotor,     tmotorVexFlashlight, openLoop, reversed)
#pragma config(Motor,  port3,           liftMotor1,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           wheelFrontRight, tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port5,           wheelBackRight, tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port6,           wheelFrontLeft, tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port7,           wheelBackLeft, tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port8,           clawLiftMotor, tmotorVexFlashlight, openLoop, reversed)
#pragma config(Motor,  port9,           liftMotor2,    tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//////////////////////////////////////////////////////////////////////////////////////
//								--= TRIPLE LIFT BOT =--								//
//////////////////////////////////////////////////////////////////////////////////////

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

//////////////////
// DEPENDENCIES //
//////////////////

#include "BlinkModule.c"
#include "BatteryModule.c"
#include "DriverControlModule.c"
#include "PIDLoopModule.c"
#include "AutonomousModule.c"

//////////////////////////
// PRE-AUTONOMOUS SETUP //
//////////////////////////

void pre_auton()
{
	writeDebugStreamLine("[Mode]: Setting up the robot...");
	// Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
	// Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
	bStopTasksBetweenModes = false; // This must be disabled to allow the PID Loop.

	// Start the blink debug handler.
	startTask(blink);
	short id = startBlinkTask(Info, Medium);

	// Initialize the driver configuration and button "event" handler.
	startTask(buttonHandler);

	// Start the battery monitor.
	startTask(batteryMonitor);

	// Setup the PID loop.
	pidCalibrate();

	wait1Msec(500);
	stopBlinkTask(id);
	writeDebugStreamLine("[Mode]: Setup complete!");
}

/////////////////////
// AUTONOMOUS MODE //
/////////////////////

task autonomous()
{
	/*short id = startBlinkTask(Info, Slow);
	writeDebugStreamLine("[Mode]: Autonomous mode enabled!");
	float sonarAverage = 0;
	repeat (10) {
		sonarAverage += SensorValue[sonar];
		wait1Msec(10);
	}
	sonarAverage = sonarAverage / 10;

	if (sonarAverage <= 25) {
		// Placed further from autoloader.
		strafe(-127); // Move up to the corner.
		while (SensorValue[sonar] > 2) {
			wait1Msec(10);
		}
		halt();
		rotate(-127, 1); // Face the wall.
		strafe(-127, 1); // Meet the autoloader.
		wait1Msec(3000); // Grab the tower segment.
		rotate(-127, 2); // Face the tower base.
		wait1Msec(3000); // Place the tower base.
		rotate(127, 2);  // Face the wall.
		strafe(-127);	 // Meet the corner.
		while (SensorValue[sonar] > 2) {
			wait1Msec(10);
		}
		halt();
		rotate(-127, 3); // Face opposite the wall.
		strafe(127); // Return to base.
		while (SensorValue[sonar] < 25) {
			wait1Msec(10);
		}
		halt();
	} else {
		// Placed close to the autoloader. Life is easy!
		rotate(127, 2); // Turn all the way around.
		strafe(-64, 1);
		wait1Msec(3000); // Grab the tower segment.
		rotate(127, 2);
		wait1Msec(3000); // Place the tower segment.
		strafe(-64, 1);
	}
	writeDebugStreamLine("[Mode]: Autonomous mode disabled!");
	stopBlinkTask(id);*/
}

///////////////////////////
//// USER CONTROL MODE ////
///////////////////////////

task usercontrol()
{
	writeDebugStreamLine("[Mode]: User Control mode enabled!");
	while (true) {
		// Claw Control
		if (vexRT[DRIVER_CONFIG[ClawClamp]] == true) {
			// Toggle the claw power.
			if (abs(motor[clawMotor]) != 127) {
				motor[clawMotor] = 127;
			}
			motor[clawMotor] = -1 * motor[clawMotor];
		}
		// Claw Wrist
		if (DRIVER_CONFIG[ClawWristUp] != UNASSIGNED && vexRT[DRIVER_CONFIG[ClawWristUp]] == true) {
			motor[clawWristMotor] = 127;
		} else if (DRIVER_CONFIG[ClawWristDown] != UNASSIGNED && vexRT[DRIVER_CONFIG[ClawWristDown]] == true) {
			motor[clawWristMotor] = -127;
		} else if (DRIVER_CONFIG[ClawWristJoy] != UNASSIGNED) {
			motor[clawWristMotor] = trimChannel(vexRT[DRIVER_CONFIG[ClawWristJoy]]);
		}
		// Claw Lift
		if (DRIVER_CONFIG[ClawLiftUp] != UNASSIGNED && vexRT[DRIVER_CONFIG[ClawLiftUp]] == true) {
			motor[clawLiftMotor] = 127;
		} else if (DRIVER_CONFIG[ClawLiftDown] != UNASSIGNED && vexRT[DRIVER_CONFIG[ClawLiftDown]] == true) {
			motor[clawLiftMotor] = -127;
		} else if (DRIVER_CONFIG[ClawLiftJoy] != UNASSIGNED) {
			motor[clawLiftMotor] = trimChannel(vexRT[DRIVER_CONFIG[ClawLiftJoy]], 5);
		}
		// Claw Lift Macros
		if (ControllerButtonsDown[ClawLiftTopMacro] == true) {
			PID_target[ClawLift] = PID_TARGET_MAX[ClawLift];
			ControllerButtonsDown[ClawLiftTopMacro] = false;
		} else if (ControllerButtonsDown[ClawLiftBottomMacro] == true) {
			PID_target[ClawLift] = 0;
			ControllerButtonsDown[ClawLiftBottomMacro] = false;
		}

		// Lift Control
		if (DRIVER_CONFIG[LiftUp] != UNASSIGNED && vexRT[DRIVER_CONFIG[LiftUp]] == true) {
			// Add or subtract the PID target height.
			if (PID_ENABLED[MainLift])
				PID_target[MainLift] += PID_CONTROL_INCREMENTER_UP[MainLift];
			else {
				// If the PID loop is disabled, set the motor power manually.
				motor[liftMotor1] = 127;
				motor[liftMotor2] = 127;
			}
		} else if (DRIVER_CONFIG[LiftDown] != UNASSIGNED && vexRT[DRIVER_CONFIG[LiftDown]] == true) {
			if (PID_ENABLED[MainLift])
				PID_target[MainLift] -= PID_CONTROL_INCREMENTER_DOWN[MainLift];
			else {
				motor[liftMotor1] = -64;
				motor[liftMotor2] = -64;
			}
		} else if (vexRT[DRIVER_CONFIG[LiftJoy]] != UNASSIGNED) {
			// Get the power value view the joystick, then apply the proportional power to the lift. (Scaled to incrementer)
			int power = trimChannel(vexRT[DRIVER_CONFIG[LiftJoy]]);
			if (PID_ENABLED[MainLift]) {
				if (PID_target[MainLift] >= 0) {
					PID_target[MainLift] += (power / 127) * PID_CONTROL_INCREMENTER_UP[MainLift];
				} else {
					PID_target[MainLift] += (power / 127) * PID_CONTROL_INCREMENTER_DOWN[MainLift];
				}
			}
			else {
				motor[liftMotor1] = power;
				motor[liftMotor2] = power;
			}
		} else if (!PID_ENABLED[MainLift]) {
			motor[liftMotor1] = 0;
			motor[liftMotor2] = 0;
		}
		// Lift Macros
		if (ControllerButtonsDown[LiftTopMacro] == true) {
			PID_target[MainLift] = PID_TARGET_MAX[MainLift];
			ControllerButtonsDown[LiftTopMacro] = false;
		} else if (ControllerButtonsDown[LiftBottomMacro] == true) {
			PID_target[MainLift] = 0;
			ControllerButtonsDown[LiftBottomMacro] = false;
		}

		// Wheel Control
		if (DRIVER_CONFIG[MecanumRotate] == UNASSIGNED) {
			// 4 joystick drive enabled.
			int threshold = 20;
			int RX = trimChannel(vexRT[DRIVER_CONFIG[MecanumRightStrafe]]);
			int RY = trimChannel(vexRT[DRIVER_CONFIG[MecanumRightNormal]]);
			int LX = trimChannel(vexRT[DRIVER_CONFIG[MecanumLeftStrafe]]);
			int LY = trimChannel(vexRT[DRIVER_CONFIG[MecanumLeftNormal]]);

			if (abs(RX) < threshold) {
				// Straight
				motor[wheelFrontRight] = RY;
				motor[wheelBackRight] = RY;
			} else if (RX > threshold) {
				// Right
				motor[wheelFrontRight] = RX;
				motor[wheelBackRight] = -RX;
			} else if (RX < -threshold) {
				// Left
				motor[wheelFrontRight] = RX;
				motor[wheelBackRight] = -RX;
			} else {
				// Stop
				motor[wheelFrontRight] = 0;
				motor[wheelBackRight] = 0;
			}

			if (abs(LX) < threshold) {
				// Straight
				motor[wheelFrontLeft] = LY;
				motor[wheelBackLeft] = LY;
			} else if (LX > threshold) {
				// Right
				motor[wheelFrontLeft] = -LX;
				motor[wheelBackLeft] = LX;
			} else if (LX < -threshold) {
				// Left
				motor[wheelFrontLeft] = -LX;
				motor[wheelBackLeft] = LX;
			} else {
				// Stop
				motor[wheelFrontLeft] = 0;
				motor[wheelBackLeft] = 0;
			}
		} else {
			// 3 joystick drive enabled.
			motor[wheelFrontRight] 	= trimChannel(vexRT[DRIVER_CONFIG[MecanumRightNormal]])
				- trimChannel(vexRT[DRIVER_CONFIG[MecanumRotate]])
				+ trimChannel(vexRT[DRIVER_CONFIG[MecanumRightStrafe]]);
   			motor[wheelBackRight] 	= trimChannel(vexRT[DRIVER_CONFIG[MecanumRightNormal]])
   				+ abs(trimChannel(vexRT[DRIVER_CONFIG[MecanumRotate]]))
   				- trimChannel(vexRT[DRIVER_CONFIG[MecanumRightStrafe]]);
    		motor[wheelFrontLeft] 	= trimChannel(vexRT[DRIVER_CONFIG[MecanumLeftNormal]])
    			+ trimChannel(vexRT[DRIVER_CONFIG[MecanumRotate]])
    			- trimChannel(vexRT[DRIVER_CONFIG[MecanumLeftStrafe]]);
    		motor[wheelBackLeft] 	= trimChannel(vexRT[DRIVER_CONFIG[MecanumLeftNormal]])
    			+ abs(trimChannel(vexRT[DRIVER_CONFIG[MecanumRotate]]))
    			+ trimChannel(vexRT[DRIVER_CONFIG[MecanumLeftStrafe]]);
		}

		// Override controls
		if (ControllerButtonsDown[PidOverride] == true) {
			if (vexRT[DRIVER_CONFIG[LiftUp]] == true || vexRT[DRIVER_CONFIG[LiftDown]] == true
					|| trimChannel(vexRT[DRIVER_CONFIG[LiftJoy]]) != 0) {
				// Toggle the main lift system then reset motors.
				PID_ENABLED[MainLift] = !PID_ENABLED[MainLift];
				motor[liftMotor1] = 0;
				motor[liftMotor2] = 0;
				// Indicate to the DriverControlModule that we have recieved the button press.
				ControllerButtonsDown[PidOverride] = false;
			} else if (vexRT[DRIVER_CONFIG[ClawLiftUp]] == true || vexRT[DRIVER_CONFIG[ClawLiftDown]] == true
					|| trimChannel(vexRT[DRIVER_CONFIG[ClawLiftJoy]]) != 0) {
				// Toggle the claw lift system then reset motors.
				PID_ENABLED[ClawLift] = !PID_ENABLED[ClawLift];
				motor[clawLiftMotor] = 0;
				ControllerButtonsDown[PidOverride] = false;
			} else if (vexRT[DRIVER_CONFIG[ClawWristUp]] == true || vexRT[DRIVER_CONFIG[ClawWristDown]] == true
					|| trimChannel(vexRT[DRIVER_CONFIG[ClawWristJoy]]) != 0) {
				// Toggle the claw wrist system then reset motors.
				PID_ENABLED[ClawWrist] = !PID_ENABLED[ClawWrist];
				motor[clawWristMotor] = 0;
				ControllerButtonsDown[PidOverride] = false;
			}
			// No systems were designated. Exit wihout accepting button down event.
		}
	}
	writeDebugStreamLine("[Mode]: User Control mode disabled!");
}
