#pragma config(Sensor, dgtl1,  liftEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  liftTouch,      sensorTouch)
#pragma config(Sensor, dgtl4,  sonar,          sensorSONAR_inch)
#pragma config(Sensor, dgtl10, LEDR,           sensorLEDtoVCC)
#pragma config(Sensor, dgtl11, LEDY,           sensorLEDtoVCC)
#pragma config(Sensor, dgtl12, LEDG,           sensorLEDtoVCC)
#pragma config(Motor,  port1,           clawWrist,     tmotorVexFlashlight, openLoop, reversed)
#pragma config(Motor,  port2,           claw,          tmotorVexFlashlight, openLoop, reversed)
#pragma config(Motor,  port3,           liftMotor1,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           wheelFrontRight, tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port5,           wheelBackRight, tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port6,           wheelFrontLeft, tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port7,           wheelBackLeft, tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port8,           clawLift,      tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port9,           liftMotor2,    tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//////////////////////////////////////////////////////////////////////////////////////
//								--= TRIPLE LIFT BOT =--								//
//////////////////////////////////////////////////////////////////////////////////////

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

//////////////////////
// GLOBAL VARIABLES //
//////////////////////

//// PID LOOP ////
bool PID_ENABLED = true; // Non-constant allows for emergency override during run time.
const bool PID_INTEGRAL_ENABLED = false;
const bool PID_DERIVATIVE_ENABLED = false;
const int PID_POWER_MAX = 127;
const int PID_POWER_MIN = -127;
int PID_POWER_POSITIVE_DEADBAND = 32; // Amount of motor play that allows minimal movement.
int PID_POWER_NEGATIVE_DEADBAND = 0;
int PID_SYSTEM_HYSTERESIS = 8; // Solves for motor jogging without breaking PID.
const int PID_INTEGRAL_LIMIT = 50;
const int PID_INTERVALS_PER_SECOND = 100; // Essentially Hertz.

const float PID_SENSOR_SCALE = 1; // If scaling of the encoder is necessary.
const float PID_INPUT_SCALE = (1 / 77.09); // Set this to be INCH / ENCODER TICKS.
float PID_target = 0; // For setting the target height. Do not touch.
float PID_actual = 0; // For detecting actual height. Do not touch.
float PID_SIGNAL_GENERATOR_MAX = 0.95; // Percentage value for horse and carrot.
const float PID_TARGET_MAX = 2000; // Max height from the origin.

// PID Loop constants for Proportional, Integral, and Derivative.
float PID_KP = 1.00;
const float PID_KI = 0.00;
const float PID_KD = 0.00;

//// DRIVER SETTINGS ////
// List of driver settings. Buttons are bound differently per driver.
// Set the CURRENT_DRIVER variable to whoever is preconfigured.
enum Driver {Max, Parker, Justin, Aaron};
const Driver CURRENT_DRIVER = Max;

//// BATTERY MONITOR ////
const float BAT_WARN = 6.6; // When to flash LED and output voltage to debug stream.
const float BAT_INTERVALS_PER_SECOND = 10; // How often the monitor will check per second.
bool BAT_low = false; // To warn other systems of low battery. (Emergency consumption reducer.)

//// DEBUG LEDS ////
bool LED_flag = false; // Used to signal tasks to halt. Do not touch.
short LED_index = 0; // For passing information to blinkTask. Do not touch.
float LED_rate = 0; // For passing information to blinkTask. Do not touch.

//////////////////////////
// DRIVER CONFIGURATION //
//////////////////////////

short DRIVER_CONFIG[4/*sizeof(Driver) + 1*/][32];
enum RT_FUNCTION {LiftUp = 0, LiftDown, LiftJoy, LiftTopMacro, LiftBottomMacro, MecanumRightNormal, MecanumRightStrafe,
	MecanumLeftNormal, MecanumLeftStrafe, MecanumRotate,  ClawLiftUp, ClawLiftDown, ClawLiftJoy, ClawWristUp, ClawWristDown,
	ClawWristJoy, ClawClamp, ClawTopMacro, ClawBottomMacro, PidOverride, UNASSIGNED = 99};

void setupDrivers() {
	writeDebugStreamLine("[Config]: The designated driver index is %i", CURRENT_DRIVER);
	//// MAX ////
	DRIVER_CONFIG[Max][LiftUp] = Btn6U;
	DRIVER_CONFIG[Max][LiftDown] = Btn6D;
	// The LiftJoy slot can be either a joystick or UNASSIGNED.
	DRIVER_CONFIG[Max][LiftJoy] = UNASSIGNED;
	DRIVER_CONFIG[Max][LiftTopMacro] = Btn8U;
	DRIVER_CONFIG[Max][LiftBottomMacro] = Btn8D;
	// Mecanum and joystick controls should never be buttons.
	DRIVER_CONFIG[Max][MecanumRightNormal] = Ch3;
	DRIVER_CONFIG[Max][MecanumRightStrafe] = Ch4;
	DRIVER_CONFIG[Max][MecanumLeftNormal] = Ch3;
	DRIVER_CONFIG[Max][MecanumLeftStrafe] = Ch4;
	DRIVER_CONFIG[Max][MecanumRotate] = Ch1;
	DRIVER_CONFIG[Max][ClawLiftUp] = Btn5U;
	DRIVER_CONFIG[Max][ClawLiftDown] = Btn5D;
	DRIVER_CONFIG[Max][ClawLiftJoy] = UNASSIGNED;
	DRIVER_CONFIG[Max][ClawWristUp] = UNASSIGNED;
	DRIVER_CONFIG[Max][ClawWristDown] = UNASSIGNED;
	DRIVER_CONFIG[Max][ClawWristJoy] = Ch3;
	DRIVER_CONFIG[Max][ClawClamp] = Btn8R;
	DRIVER_CONFIG[Max][PidOverride] = Btn7L;

	//// PARKER ////
	DRIVER_CONFIG[Parker][LiftUp] = UNASSIGNED;
	DRIVER_CONFIG[Parker][LiftDown] = UNASSIGNED;
	DRIVER_CONFIG[Parker][LiftJoy] = Ch2;
	DRIVER_CONFIG[Parker][LiftTopMacro] = Btn8U;
	DRIVER_CONFIG[Parker][LiftBottomMacro] = Btn8D;
	DRIVER_CONFIG[Parker][MecanumRightNormal] = Ch3;
	DRIVER_CONFIG[Parker][MecanumRightStrafe] = Ch4;
	DRIVER_CONFIG[Parker][MecanumLeftNormal] = Ch3;
	DRIVER_CONFIG[Parker][MecanumLeftStrafe] = Ch4;
	DRIVER_CONFIG[Parker][MecanumRotate] = Ch1;
	DRIVER_CONFIG[Parker][PidOverride] = Btn7U;

	//// JUSTIN ////
	DRIVER_CONFIG[Justin][LiftUp] = Btn6U;
	DRIVER_CONFIG[Justin][LiftDown] = Btn6D;
	DRIVER_CONFIG[Justin][LiftJoy] = UNASSIGNED;
	DRIVER_CONFIG[Justin][MecanumRightNormal] = Ch2;
	DRIVER_CONFIG[Justin][MecanumRightStrafe] = Ch1;
	DRIVER_CONFIG[Justin][MecanumLeftNormal] = Ch3;
	DRIVER_CONFIG[Justin][MecanumLeftStrafe] = Ch4;
	DRIVER_CONFIG[Justin][MecanumRotate] = UNASSIGNED;
	DRIVER_CONFIG[Justin][PidOverride] = Btn7U;

	//// AARON ////
	DRIVER_CONFIG[Aaron][LiftUp] = UNASSIGNED;
	DRIVER_CONFIG[Aaron][LiftDown] = UNASSIGNED;
	DRIVER_CONFIG[Aaron][LiftJoy] = Ch2;
	DRIVER_CONFIG[Aaron][LiftTopMacro] = Btn5U;
	DRIVER_CONFIG[Aaron][LiftBottomMacro] = Btn5D;
	DRIVER_CONFIG[Aaron][MecanumRightNormal] = Ch3;
	DRIVER_CONFIG[Aaron][MecanumRightStrafe] = Ch4;
	DRIVER_CONFIG[Aaron][MecanumLeftNormal] = Ch3;
	DRIVER_CONFIG[Aaron][MecanumLeftStrafe] = Ch4;
	DRIVER_CONFIG[Aaron][MecanumRotate] = Ch1;
	DRIVER_CONFIG[Aaron][PidOverride] = Btn7U;
}

/////////////////////////
// PID CONTROLLER LOOP //
/////////////////////////
	float filteredTarget = 0;
	float power = 0;
	float error = 0;
	float lastError = 0;
	float integral = 0;
	float derivative = 0;
	float lastTarget = 0;
	float lastActual = 0;
task pidController() {


	// Reset the sensor value. (Pre-Autonomous should set lift to bottom)
	SensorValue[liftEncoder] = 0;

	while (true) {
		if (PID_ENABLED) {
			// Grab the actual sensor value, then scale it to real world units.
			lastActual = PID_actual;
			PID_actual = SensorValue[liftEncoder] * PID_SENSOR_SCALE;

			// Target filter using a signal generator (horse and carrot method).
			filteredTarget = PID_SIGNAL_GENERATOR_MAX * lastTarget + (1.00 - PID_SIGNAL_GENERATOR_MAX) * PID_target;
			lastTarget = filteredTarget;

			if (PID_target > PID_TARGET_MAX) {
				PID_target = PID_TARGET_MAX;
			}

			// Calculate the error.
			error = PID_actual - filteredTarget;
			if (abs(error) < PID_SYSTEM_HYSTERESIS) {
				error = 0;
			}

			/*if (PID_actual == 0 && (SensorValue[liftTouch] != 1)) {
				// If we are supposedly at 0, and are not touching the bottom,
				// increase the error to meet the bottom.
				error = -15;
			} else*/ if (error < 0 && SensorValue[liftTouch] == 1) {
				// If we are at the bottom, and we are supposedly not,
				// reset the error, actual, and encoder.
				error = 0;
				PID_actual = 0;
				SensorValue[liftEncoder] = 0;
			}

			if (PID_INTEGRAL_ENABLED) {
				// Accumulate error to fill the gap.
				if (abs(error) < PID_INTEGRAL_LIMIT) {
					integral += error;
				}
				if(PID_KI == 0)
				    integral = 0;
			}
			else integral = 0;

			if (PID_DERIVATIVE_ENABLED) {
				// Predict future change via derivative.
				derivative = (error - lastError);
				lastError = error;
			} else {
				derivative = 0;
			}

			// Calculate the power necessary to correct the found error.
			// Negations are to keep error and power values in a logical context.
			power = -1 * ((PID_KP * error) + (PID_KI * integral)  + (PID_KD * derivative));

			// Limit the power sent to motors. (Can't exceed the byte)
			if (power > PID_POWER_MAX) {
				power = PID_POWER_MAX;
			} else if (power < PID_POWER_MIN) {
				power = PID_POWER_MIN;
			}

			// If the power level is below the deadband, increase it so that the
			// motor is actually moving toward its goal.
			if (power > 0 && power < PID_POWER_POSITIVE_DEADBAND && PID_POWER_POSITIVE_DEADBAND != 0 && power != 0) {
				power = PID_POWER_POSITIVE_DEADBAND;
			} else if (power < 0 && power > PID_POWER_NEGATIVE_DEADBAND && PID_POWER_NEGATIVE_DEADBAND != 0 && power != 0) {
				power = PID_POWER_NEGATIVE_DEADBAND;
			} else if (power == 0 || error == 0) {
				// Apply hold power.
				power = PID_POWER_POSITIVE_DEADBAND  / 2;
			}

			// Set the motor power value.
			// Type cast to keep from wrongly setting the motors.
			// Negations are to keep error and power values in a logical context.
			motor[liftMotor1] = (int) power;
			motor[liftMotor2] = (int) power;

			// Indicate that PID is struggling to meet its target.
			if (PID_actual == lastActual && abs(error) >= 300 && (power >= PID_POWER_POSITIVE_DEADBAND || power <= PID_POWER_NEGATIVE_DEADBAND)) {
				SensorValue[LEDR] = 1;
			} else {
				SensorValue[LEDR] = 0;
			}

		} else {
			// Reset the variables.
			error = 0;
			lastError = 0;
			integral = 0;
			derivative = 0;
			power = 0;
			// Reset the target so it doesn't jump when it is re-enabled.
			PID_target = 0;
			SensorValue[LEDY] = 1;
			// Be sure to stop the motor as well. (Externally once, rather than many times)
		}

		// Repeat at defined delta time, in Hertz.
		wait1Msec(1000 / PID_INTERVALS_PER_SECOND);
	}
}

///////////////////////
// TASKS & FUNCTIONS //
///////////////////////

//// DEBUG LEDS ////
task blinkTask() {
	short led = LED_index;
	float rate = LED_rate;
	while (true) {
		SensorValue[led] = !SensorValue[led]; // Toggle led.
		wait1Msec(1000 / rate); // Toggle at given rate.
		if (LED_flag == true) {
			// When halt command recieved, break the loop thus ending the task.
			LED_flag = false;
			break;
		}
	}
}

void startBlink (short led, float rate) {
	// Blinks given LED at given rate (hertz) until halted.
	if (rate > 50 || rate <= 0) {
		// Invalid rate.
		writeDebugStreamLine("[LED]: The set rate is invalid. Aborting blink task.");
		return;
	} else {
		LED_index = led;
		LED_rate = rate;
		LED_flag = false; // Just to be safe.
		startTask(blinkTask);
	}
}

void haltBlink() {
	LED_flag = true;
}

//// BATTERY LEVEL MONITOR ////
task batteryMonitor() {
	while (true) {
		// Grabs an average sampling of the battery level then scales. (20 samples)
		float batAvg = ((float) nAvgBatteryLevel) * 0.001;
		// Interesting stats: http://www.vexrobotics.com/wiki/Quazar%27s_Battery_Load_Test
		// If the battery level is low, start a warning signal.
		if (batAvg < BAT_WARN) {
			startBlink(LEDR, batAvg);
			BAT_low = true;
			writeDebugStreamLine("[Battery]: The battery is low. Its voltage is reading %1.3f V", batAvg);
			// Enter next low battery check loop.
			while (true) {
				float batAvg = ((float) nAvgBatteryLevel) * 0.001;
				if (batAvg > BAT_WARN) {
					// Voltage change? Exit back into main loop.
					haltBlink();
					BAT_low = false;
					break;
				}
				wait1Msec(1000 / (BAT_INTERVALS_PER_SECOND / 2)); // Run at reduced pace, helps conserve battery.
			}
		}
		wait1Msec(1000 / BAT_INTERVALS_PER_SECOND);
	}
}

//// MOVEMENT FUNCTIONS ////
void setTarget (int height) {
	// Sets the PID target to height.
	// Height is determined by the PID_INPUT_SCALE value (likely inches).
	PID_target = height / PID_INPUT_SCALE;
}

void surge (int power, float time = 0) {
	// To move forward or backward. (Nautical term)
	// Positive is forward, negative is backward.
	motor[wheelFrontRight] = power;
	motor[wheelBackRight] = power;
	motor[wheelFrontLeft] = power;
	motor[wheelBackLeft] = power;
	if (time != 0) {
		wait1Msec(time);
		motor[wheelFrontRight] = 0;
		motor[wheelBackRight] = 0;
		motor[wheelFrontLeft] = 0;
		motor[wheelBackLeft] = 0;
	}
}

void strafe (int power, float time = 0) {
	// To move left or right without rotation.
	// Positive is to the right, negative is to the left.
	motor[wheelFrontRight] = -power;
	motor[wheelBackRight] = power;
	motor[wheelFrontLeft] = power;
	motor[wheelBackLeft] = -power;
	if (time != 0) {
		wait1Msec(time);
		motor[wheelFrontRight] = 0;
		motor[wheelBackRight] = 0;
		motor[wheelFrontLeft] = 0;
		motor[wheelBackLeft] = 0;
	}
}

void rotate (int power, float time = 0) {
	// To turn left or right without surge movement.
	// Positive is to the right, negative is to the left.
	motor[wheelFrontRight] = -power;
	motor[wheelBackRight] = -power;
	motor[wheelFrontLeft] = power;
	motor[wheelBackLeft] = power;
	if (time != 0) {
		wait1Msec(time);
		motor[wheelFrontRight] = 0;
		motor[wheelBackRight] = 0;
		motor[wheelFrontLeft] = 0;
		motor[wheelBackLeft] = 0;
	}
}

void elevate (int height) {
	PID_target = height;
}

void halt () {
	motor[wheelFrontRight] = 0;
	motor[wheelBackRight] = 0;
	motor[wheelFrontLeft] = 0;
	motor[wheelBackLeft] = 0;
}

//// PRE-AUTONOMOUS SETUP ////
void pre_auton()
{
	writeDebugStreamLine("[Mode]: Setting up the robot...");
	// Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
	// Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
	bStopTasksBetweenModes = false; // This must be disabled to allow the PID Loop.

	// Initialize the driver configuration.
	setupDrivers();

	// Start the battery monitor.
	startTask(batteryMonitor);

	// Reset the lift to the bottom position.
	if (SensorType[liftTouch] != sensorNone) {
		motor[liftMotor1] = -64;
		motor[liftMotor2] = -64;
		startBlink(LEDG, 1);
		while (SensorValue[liftTouch] != 1) {
			// Wait...
			wait1Msec(10);
		}
		motor[liftMotor1] = 0;
		motor[liftMotor2] = 0;

		// Set the encoder to 0 for the PID loop.
		SensorValue[liftEncoder] = 0;
		haltBlink();
		SensorValue[LEDR] = 1;
		SensorValue[LEDY] = 1;
		SensorValue[LEDG] = 1;
		wait1Msec(500);
		SensorValue[LEDR] = 0;
		SensorValue[LEDY] = 0;
		SensorValue[LEDG] = 0;
	} else {
		// May not work. Inserted regardless.
		writeDebugStreamLine("[Hardware]: The limit switch is not installed. Aborting lift preset.");
		SensorValue[LEDR] = 1;
	}

	// Startup the PID system.
	startTask(pidController);
	writeDebugStreamLine("[Mode]: Setup complete!");
}

//// AUTONOMOUS MODE ////
task autonomous()
{
	/*SensorValue[LEDG] = 1;
	writeDebugStreamLine("[Mode]: Autonomous mode enabled!");
	float sonarAverage = 0;
	repeat (10) {
		sonarAverage += SensorValue[sonar];
		wait1Msec(10);
	}
	sonarAverage = sonarAverage / 10;

	if (sonarAverage <= 25) {
		// Placed further from autoloader.
		strafe(-127); // Move up to the corner.
		while (SensorValue[sonar] > 2) {
			wait1Msec(10);
		}
		halt();
		rotate(-127, 1); // Face the wall.
		strafe(-127, 1); // Meet the autoloader.
		wait1Msec(3000); // Grab the tower segment.
		rotate(-127, 2); // Face the tower base.
		wait1Msec(3000); // Place the tower base.
		rotate(127, 2);  // Face the wall.
		strafe(-127);	 // Meet the corner.
		while (SensorValue[sonar] > 2) {
			wait1Msec(10);
		}
		halt();
		rotate(-127, 3); // Face opposite the wall.
		strafe(127); // Return to base.
		while (SensorValue[sonar] < 25) {
			wait1Msec(10);
		}
		halt();
	} else {
		// Placed close to the autoloader. Life is easy!
		rotate(127, 2); // Turn all the way around.
		strafe(-64, 1);
		wait1Msec(3000); // Grab the tower segment.
		rotate(127, 2);
		wait1Msec(3000); // Place the tower segment.
		strafe(-64, 1);
	}
	writeDebugStreamLine("[Mode]: Autonomous mode disabled!");
	SensorValue[LEDG] = 0;*/
}

//// USER CONTROL MODE ////
task usercontrol()
{
	writeDebugStreamLine("[Mode]: User Control mode enabled!");
	while (true) {
		// Claw Control
		if (vexRT[DRIVER_CONFIG[CURRENT_DRIVER][ClawClamp]] == true) {
			// Toggle the claw power.
			motor[claw] = -1 * motor[claw];
		}
		// Claw Wrist
		if (DRIVER_CONFIG[CURRENT_DRIVER][ClawWristUp] != UNASSIGNED && vexRT[DRIVER_CONFIG[CURRENT_DRIVER][ClawWristUp]] == true) {
			motor[clawWrist] = 127;
		} else if (DRIVER_CONFIG[CURRENT_DRIVER][ClawWristDown] != UNASSIGNED && vexRT[DRIVER_CONFIG[CURRENT_DRIVER][ClawWristDown]] == true) {
			motor[clawWrist] = -127;
		} else if (DRIVER_CONFIG[CURRENT_DRIVER][ClawWristJoy] != UNASSIGNED) {
			motor[clawWrist] = vexRT[DRIVER_CONFIG[CURRENT_DRIVER][ClawWristJoy]];
		}
		// Claw Lift
		if (DRIVER_CONFIG[CURRENT_DRIVER][ClawLiftUp] != UNASSIGNED && vexRT[DRIVER_CONFIG[CURRENT_DRIVER][ClawLiftUp]] == true) {
			motor[clawLift] = 127;
		} else if (DRIVER_CONFIG[CURRENT_DRIVER][ClawLiftDown] != UNASSIGNED && vexRT[DRIVER_CONFIG[CURRENT_DRIVER][ClawLiftDown]] == true) {
			motor[clawLift] = -127;
		} else if (DRIVER_CONFIG[CURRENT_DRIVER][ClawLiftJoy] != UNASSIGNED) {
			motor[clawLift] = vexRT[DRIVER_CONFIG[CURRENT_DRIVER][ClawLiftJoy]];
		}

		// Lift Control
		if (DRIVER_CONFIG[CURRENT_DRIVER][LiftUp] != UNASSIGNED && vexRT[DRIVER_CONFIG[CURRENT_DRIVER][LiftUp]] == true) {
			// Add or subtract the PID target height.
			if (PID_ENABLED)
				PID_target += 0.3;
			else {
				// If the PID loop is disabled, set the motor power manually.
				motor[liftMotor1] = 127;
				motor[liftMotor2] = 127;
			}
		} else if (DRIVER_CONFIG[CURRENT_DRIVER][LiftDown] != UNASSIGNED && vexRT[DRIVER_CONFIG[CURRENT_DRIVER][LiftDown]] == true) {
			if (PID_ENABLED)
				PID_target -= 0.3;
			else {
				motor[liftMotor1] = -64;
				motor[liftMotor2] = -64;
			}
		} else if (vexRT[DRIVER_CONFIG[CURRENT_DRIVER][LiftJoy]] != UNASSIGNED) {
			// Get the power value view the joystick, then apply the proportional power to the lift.
			int power = vexRT[DRIVER_CONFIG[CURRENT_DRIVER][LiftJoy]];
			if (PID_ENABLED) {
				PID_target += power / 4;
			}
			else {
				motor[liftMotor1] = power;
				motor[liftMotor2] = power;
			}
		} else if (!PID_ENABLED) {
			motor[liftMotor1] = 0;
			motor[liftMotor2] = 0;
		}

		if (/*true == false*/DRIVER_CONFIG[CURRENT_DRIVER][MecanumRotate] == UNASSIGNED) {
			// 4 joystick drive enabled.
			int threshold = 20;
			int RX = vexRT[DRIVER_CONFIG[CURRENT_DRIVER][MecanumRightStrafe]];
			int RY = vexRT[DRIVER_CONFIG[CURRENT_DRIVER][MecanumRightNormal]];
			int LX = vexRT[DRIVER_CONFIG[CURRENT_DRIVER][MecanumLeftStrafe]];
			int LY = vexRT[DRIVER_CONFIG[CURRENT_DRIVER][MecanumLeftNormal]];

			if (abs(RX) < threshold) {
				// Straight
				motor[wheelFrontRight] = RY;
				motor[wheelBackRight] = RY;
			} else if (RX > threshold) {
				// Right
				motor[wheelFrontRight] = RX;
				motor[wheelBackRight] = -RX;
			} else if (RX < -threshold) {
				// Left
				motor[wheelFrontRight] = RX;
				motor[wheelBackRight] = -RX;
			} else {
				// Stop
				motor[wheelFrontRight] = 0;
				motor[wheelBackRight] = 0;
			}

			if (abs(LX) < threshold) {
				// Straight
				motor[wheelFrontLeft] = LY;
				motor[wheelBackLeft] = LY;
			} else if (LX > threshold) {
				// Right
				motor[wheelFrontLeft] = -LX;
				motor[wheelBackLeft] = LX;
			} else if (LX < -threshold) {
				// Left
				motor[wheelFrontLeft] = -LX;
				motor[wheelBackLeft] = LX;
			} else {
				// Stop
				motor[wheelFrontLeft] = 0;
				motor[wheelBackLeft] = 0;
			}
		} else {
			// 3 joystick drive enabled.
			motor[wheelFrontRight] 	= vexRT[DRIVER_CONFIG[CURRENT_DRIVER][MecanumRightNormal]]
				- vexRT[DRIVER_CONFIG[CURRENT_DRIVER][MecanumRotate]]
				+ vexRT[DRIVER_CONFIG[CURRENT_DRIVER][MecanumRightStrafe]];
   			motor[wheelBackRight] 	= vexRT[DRIVER_CONFIG[CURRENT_DRIVER][MecanumRightNormal]]
   				- vexRT[DRIVER_CONFIG[CURRENT_DRIVER][MecanumRotate]]
   				- vexRT[DRIVER_CONFIG[CURRENT_DRIVER][MecanumRightStrafe]];
    		motor[wheelFrontLeft] 	= vexRT[DRIVER_CONFIG[CURRENT_DRIVER][MecanumLeftNormal]]
    			+ vexRT[DRIVER_CONFIG[CURRENT_DRIVER][MecanumRotate]]
    			- vexRT[DRIVER_CONFIG[CURRENT_DRIVER][MecanumLeftStrafe]];
    		motor[wheelBackLeft] 	= vexRT[DRIVER_CONFIG[CURRENT_DRIVER][MecanumLeftNormal]]
    			+ vexRT[DRIVER_CONFIG[CURRENT_DRIVER][MecanumRotate]]
    			+ vexRT[DRIVER_CONFIG[CURRENT_DRIVER][MecanumLeftStrafe]];
		}

		// Override controls
		if (vexRT[DRIVER_CONFIG[CURRENT_DRIVER][PidOverride]] == true) {
			// Toggle the the PID loop, then stop motors.
			PID_ENABLED = !PID_ENABLED;
			motor[liftMotor1] = 0;
			motor[liftMotor2] = 0;
			SensorValue[LEDY] = 0;
		}
	}
	writeDebugStreamLine("[Mode]: User Control mode disabled!");
}
